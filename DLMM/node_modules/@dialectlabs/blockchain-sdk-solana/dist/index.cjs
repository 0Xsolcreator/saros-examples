"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA: () => DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA,
  DialectSolanaWalletAdapterWrapper: () => DialectSolanaWalletAdapterWrapper,
  DialectWalletAdapterSolanaEd25519TokenSigner: () => DialectWalletAdapterSolanaEd25519TokenSigner,
  NodeDialectSolanaWalletAdapter: () => NodeDialectSolanaWalletAdapter,
  SOLANA_ED25519_TOKEN_SIGNER_ALG: () => SOLANA_ED25519_TOKEN_SIGNER_ALG,
  SOLANA_ED25519_TOKEN_SIGNER_ALG_BACKWARD_COMPATIBLE: () => SOLANA_ED25519_TOKEN_SIGNER_ALG_BACKWARD_COMPATIBLE,
  SolanaEd25519AuthenticationFacadeFactory: () => SolanaEd25519AuthenticationFacadeFactory,
  SolanaEd25519TokenSigner: () => SolanaEd25519TokenSigner,
  SolanaSdkFactory: () => SolanaSdkFactory,
  SolanaTxAuthenticationFacadeFactory: () => SolanaTxAuthenticationFacadeFactory
});
module.exports = __toCommonJS(src_exports);

// src/wallet-adapter/dialect-solana-wallet-adapter-wrapper.ts
var import_sdk = require("@dialectlabs/sdk");
var DialectSolanaWalletAdapterWrapper = class _DialectSolanaWalletAdapterWrapper {
  constructor(delegate) {
    this.delegate = delegate;
  }
  get publicKey() {
    if (!this.delegate.publicKey) {
      throw new import_sdk.UnsupportedOperationError(
        "Public key not available",
        "Wallet does not have public key, please provide a valid public key."
      );
    }
    return this.delegate.publicKey;
  }
  get canEncrypt() {
    return Boolean(this.publicKey && this.delegate.diffieHellman);
  }
  static create(adapter) {
    return new _DialectSolanaWalletAdapterWrapper(adapter);
  }
  signTransaction(transaction) {
    if (!this.delegate.signTransaction) {
      throw new import_sdk.UnsupportedOperationError(
        "Signing not supported",
        "Wallet does not support signing, please use wallet-adapter that supports signTransaction() operation."
      );
    }
    return this.delegate.signTransaction(transaction);
  }
  signAllTransactions(transactions) {
    if (!this.delegate.signAllTransactions) {
      throw new import_sdk.UnsupportedOperationError(
        "Signing not supported",
        "Wallet does not support signing, please use wallet-adapter that supports signAllTransactions() operation."
      );
    }
    return this.delegate.signAllTransactions(transactions);
  }
  signMessage(message) {
    if (!this.delegate.signMessage) {
      throw new import_sdk.UnsupportedOperationError(
        "Message signing not supported",
        "Wallet does not support message signing, please use wallet-adapter that supports signMessage() operation."
      );
    }
    return this.delegate.signMessage(message);
  }
  diffieHellman() {
    if (!this.delegate.diffieHellman) {
      throw new import_sdk.UnsupportedOperationError(
        "Encryption not supported",
        "Wallet does not support encryption, please use wallet-adapter that supports diffieHellman() operation."
      );
    }
    return this.delegate.diffieHellman(this.publicKey.toBytes());
  }
  canSignMessage() {
    return Boolean(this.delegate.signMessage);
  }
  canSignTransaction() {
    return Boolean(this.delegate.signTransaction);
  }
};

// src/wallet-adapter/node-dialect-solana-wallet-adapter.ts
var import_web3 = require("@solana/web3.js");
var import_tweetnacl = __toESM(require("tweetnacl"), 1);
var import_ed2curve = __toESM(require("ed2curve"), 1);
var NodeDialectSolanaWalletAdapter = class _NodeDialectSolanaWalletAdapter {
  constructor(keypair) {
    this.keypair = keypair;
  }
  get publicKey() {
    return this.keypair.publicKey;
  }
  static create(keypair) {
    if (keypair) {
      console.log(
        `Initializing ${_NodeDialectSolanaWalletAdapter.name} using provided ${keypair.publicKey.toBase58()} key.`
      );
      return new _NodeDialectSolanaWalletAdapter(keypair);
    } else if (process.env.DIALECT_SDK_CREDENTIALS) {
      const privateKey = process.env.DIALECT_SDK_CREDENTIALS;
      const keypair2 = import_web3.Keypair.fromSecretKey(
        new Uint8Array(JSON.parse(privateKey))
      );
      console.log(
        `Initializing ${_NodeDialectSolanaWalletAdapter.name} using env-provided ${keypair2.publicKey.toBase58()} key.`
      );
      return new _NodeDialectSolanaWalletAdapter(keypair2);
    } else {
      throw new Error(
        `Error initializing ${_NodeDialectSolanaWalletAdapter.name}: SDK credential must be provided.`
      );
    }
  }
  async signTransaction(transaction) {
    if (transaction instanceof import_web3.VersionedTransaction) {
      const signer = {
        publicKey: this.keypair.publicKey,
        secretKey: this.keypair.secretKey
      };
      const signers = [signer];
      transaction.sign(signers);
    } else {
      transaction.partialSign(this.keypair);
    }
    return transaction;
  }
  async signAllTransactions(transactions) {
    return Promise.all(transactions.map((tx) => this.signTransaction(tx)));
  }
  signMessage(message) {
    return Promise.resolve(import_tweetnacl.default.sign.detached(message, this.keypair.secretKey));
  }
  diffieHellman(publicKey) {
    const keypair = import_ed2curve.default.convertKeyPair({
      secretKey: this.keypair.secretKey,
      publicKey
    });
    if (!keypair) {
      throw new Error("Failed to convert keypair");
    }
    return Promise.resolve(keypair);
  }
};

// src/auth/ed25519/solana-ed25519-authentication-facade-factory.ts
var import_sdk3 = require("@dialectlabs/sdk");

// src/auth/ed25519/solana-ed25519-token-validator.ts
var import_sdk2 = require("@dialectlabs/sdk");
var import_tweetnacl2 = __toESM(require("tweetnacl"), 1);

// src/sdk/constants.ts
var DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA = "solana";

// src/auth/ed25519/solana-ed25519-token-signer.ts
var SOLANA_ED25519_TOKEN_SIGNER_ALG = `${DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA}-ed25519`;
var SOLANA_ED25519_TOKEN_SIGNER_ALG_BACKWARD_COMPATIBLE = "ed25519";
var SolanaEd25519TokenSigner = class {
  constructor() {
    this.alg = SOLANA_ED25519_TOKEN_SIGNER_ALG;
  }
};
var DialectWalletAdapterSolanaEd25519TokenSigner = class extends SolanaEd25519TokenSigner {
  constructor(dialectWalletAdapter) {
    super();
    this.dialectWalletAdapter = dialectWalletAdapter;
  }
  get subject() {
    return this.dialectWalletAdapter.publicKey.toBase58();
  }
  get subjectPublicKey() {
    return this.dialectWalletAdapter.publicKey;
  }
  async sign(payload) {
    return {
      payload,
      signature: await this.dialectWalletAdapter.signMessage(payload)
    };
  }
};

// src/auth/ed25519/solana-ed25519-token-validator.ts
var SolanaEd25519TokenValidator = class extends import_sdk2.TokenValidator {
  canValidate(tokenHeader) {
    return tokenHeader.alg === SOLANA_ED25519_TOKEN_SIGNER_ALG || tokenHeader.alg === SOLANA_ED25519_TOKEN_SIGNER_ALG_BACKWARD_COMPATIBLE;
  }
  isSignatureValid(token) {
    const signedPayload = token.base64Header + "." + token.base64Body;
    const signingPayload = new TextEncoder().encode(signedPayload);
    return import_tweetnacl2.default.sign.detached.verify(
      signingPayload,
      token.signature,
      new import_sdk2.Ed25519PublicKey(token.body.sub_jwk ?? token.body.sub).toBytes()
    );
  }
  performExtraValidation(token) {
    if (!token.body.sub_jwk) {
      return true;
    }
    return token.body.sub === token.body.sub_jwk;
  }
};

// src/auth/ed25519/solana-ed25519-authentication-facade-factory.ts
var SolanaEd25519AuthenticationFacadeFactory = class _SolanaEd25519AuthenticationFacadeFactory extends import_sdk3.AuthenticationFacadeFactory {
  constructor(tokenSigner) {
    super();
    this.tokenSigner = tokenSigner;
  }
  static createAuthenticator() {
    return new import_sdk3.Authenticator(
      new import_sdk3.TokenParser(new import_sdk3.Ed25519TokenBodyParser()),
      new SolanaEd25519TokenValidator()
    );
  }
  get() {
    return new import_sdk3.AuthenticationFacade(
      this.tokenSigner,
      new import_sdk3.DefaultTokenGenerator(this.tokenSigner),
      _SolanaEd25519AuthenticationFacadeFactory.createAuthenticator()
    );
  }
};

// src/auth/tx/solana-tx-authentication-facade-factory.ts
var import_sdk7 = require("@dialectlabs/sdk");

// src/auth/tx/solana-tx-token-body-parser.ts
var import_sdk4 = require("@dialectlabs/sdk");
var import_web32 = require("@solana/web3.js");
var SolanaTxTokenBodyParser = class extends import_sdk4.TokenBodyParser {
  parse(base64Body) {
    const byteBody = (0, import_sdk4.bytesFromBase64)(base64Body);
    const tx = import_web32.Transaction.from(byteBody);
    const dataInstruction = tx.instructions.filter(
      (it) => it.programId === tx.feePayer
    )[0];
    if (!dataInstruction) {
      throw new import_sdk4.TokenStructureValidationError();
    }
    const [headerBase64, bodyBase64] = dataInstruction.data.toString().split(".");
    if (!headerBase64 || !bodyBase64) {
      throw new import_sdk4.TokenStructureValidationError();
    }
    return (0, import_sdk4.jsonParseFromBase64)(bodyBase64);
  }
};

// src/auth/tx/solana-tx-token-generator.ts
var import_sdk5 = require("@dialectlabs/sdk");
var SolanaTxTokenGenerator = class extends import_sdk5.TokenGenerator {
  async generate(ttlSeconds) {
    const header = this.header();
    const base64Header = (0, import_sdk5.jsonStringifyToBase64)(header);
    const body = this.body(ttlSeconds);
    const base64Body = (0, import_sdk5.jsonStringifyToBase64)(body);
    const { signature, base64Signature, signedPayload } = await this.sign(
      base64Header,
      base64Body,
      this.signer
    );
    const base64SignedBody = (0, import_sdk5.bytesToBase64)(signedPayload);
    const rawValue = `${base64Header}.${base64SignedBody}.${base64Signature}`;
    return {
      rawValue,
      body,
      header,
      signature,
      base64Signature,
      base64Body: base64SignedBody,
      base64Header
    };
  }
};

// src/auth/tx/solana-tx-token-validator.ts
var import_base64 = require("@stablelib/base64");
var import_web34 = require("@solana/web3.js");
var import_sdk6 = require("@dialectlabs/sdk");

// src/auth/tx/solana-tx-token-signer.ts
var import_web33 = require("@solana/web3.js");
var SOLANA_TX_TOKEN_SIGNER_ALG = `${DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA}-tx`;
var SolanaTxTokenSigner = class {
  constructor() {
    this.alg = SOLANA_TX_TOKEN_SIGNER_ALG;
  }
};
var DialectWalletAdapterSolanaTxTokenSigner = class extends SolanaTxTokenSigner {
  constructor(dialectWalletAdapter) {
    super();
    this.dialectWalletAdapter = dialectWalletAdapter;
  }
  get subject() {
    return this.dialectWalletAdapter.publicKey.toBase58();
  }
  get subjectPublicKey() {
    return this.dialectWalletAdapter.publicKey;
  }
  async sign(payload) {
    const tx = new import_web33.Transaction();
    const subjectPublicKey = new import_web33.PublicKey(this.subject);
    tx.add(
      new import_web33.TransactionInstruction({
        keys: [
          {
            pubkey: subjectPublicKey,
            isSigner: false,
            isWritable: false
          }
        ],
        programId: subjectPublicKey,
        data: Buffer.from(payload)
      })
    );
    tx.recentBlockhash = import_web33.PublicKey.default.toString();
    tx.feePayer = subjectPublicKey;
    const signedTx = await this.dialectWalletAdapter.signTransaction(tx);
    return {
      payload: signedTx.serialize(),
      signature: signedTx.signature
    };
  }
};

// src/auth/tx/solana-tx-token-validator.ts
var SolanaTxTokenValidator = class extends import_sdk6.TokenValidator {
  canValidate(tokenHeader) {
    return tokenHeader.alg === SOLANA_TX_TOKEN_SIGNER_ALG;
  }
  isSignatureValid(token) {
    const byteBody = (0, import_base64.decodeURLSafe)(token.base64Body);
    const tx = import_web34.Transaction.from(byteBody);
    tx.recentBlockhash = import_web34.PublicKey.default.toString();
    return tx.verifySignatures();
  }
  performExtraValidation(token) {
    if (!token.body.sub_jwk) {
      return true;
    }
    return token.body.sub === token.body.sub_jwk;
  }
};

// src/auth/tx/solana-tx-authentication-facade-factory.ts
var SolanaTxAuthenticationFacadeFactory = class _SolanaTxAuthenticationFacadeFactory extends import_sdk7.AuthenticationFacadeFactory {
  constructor(tokenSigner) {
    super();
    this.tokenSigner = tokenSigner;
  }
  static createAuthenticator() {
    return new import_sdk7.Authenticator(
      new import_sdk7.TokenParser(new SolanaTxTokenBodyParser()),
      new SolanaTxTokenValidator()
    );
  }
  get() {
    return new import_sdk7.AuthenticationFacade(
      this.tokenSigner,
      new SolanaTxTokenGenerator(this.tokenSigner),
      _SolanaTxAuthenticationFacadeFactory.createAuthenticator()
    );
  }
};

// src/sdk/sdk.ts
var import_sdk9 = require("@dialectlabs/sdk");

// src/encryption/encryption-keys-provider.ts
var import_sdk8 = require("@dialectlabs/sdk");
var DialectSolanaWalletAdapterEncryptionKeysProvider = class extends import_sdk8.EncryptionKeysProvider {
  constructor(dialectWalletAdapter) {
    super();
    this.dialectWalletAdapter = dialectWalletAdapter;
  }
  isAvailable() {
    return this.dialectWalletAdapter.canEncrypt;
  }
  getFailSafe() {
    return this.dialectWalletAdapter.canEncrypt ? this.dialectWalletAdapter.diffieHellman() : Promise.resolve(null);
  }
  getFailFast() {
    return this.dialectWalletAdapter.diffieHellman();
  }
};

// src/sdk/sdk.ts
var SolanaSdkFactory = class _SolanaSdkFactory {
  constructor(solanaConfigProps) {
    this.solanaConfigProps = solanaConfigProps;
  }
  static create(props) {
    return new _SolanaSdkFactory(props);
  }
  static logConfiguration(config, environment) {
    if (environment !== "production") {
      console.log(
        `Initializing Dialect Solana SDK using configuration:
Solana settings:
  Wallet public key: ${config.wallet.publicKey}
  Wallet supports encryption: ${config.wallet.canEncrypt}
  Wallet supports authentication: ${config.wallet.canSignMessage() || config.wallet.canSignTransaction()}
`
      );
    }
  }
  create(config) {
    const solanaConfig = this.initializeSolanaConfig();
    const wallet = solanaConfig.wallet;
    _SolanaSdkFactory.logConfiguration(solanaConfig, config.environment);
    const walletAdapterEncryptionKeysProvider = new DialectSolanaWalletAdapterEncryptionKeysProvider(wallet);
    const encryptionKeysProvider = import_sdk9.EncryptionKeysProvider.create(
      walletAdapterEncryptionKeysProvider,
      config.encryptionKeysStore
    );
    const authenticationFacadeFactory = wallet.canSignMessage() ? new SolanaEd25519AuthenticationFacadeFactory(
      new DialectWalletAdapterSolanaEd25519TokenSigner(wallet)
    ) : new SolanaTxAuthenticationFacadeFactory(
      new DialectWalletAdapterSolanaTxTokenSigner(wallet)
    );
    const authenticationFacade = authenticationFacadeFactory.get();
    return {
      type: DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA,
      encryptionKeysProvider,
      authenticationFacade,
      config: solanaConfig,
      info: {
        supportsOnChainMessaging: false
      }
    };
  }
  initializeSolanaConfig() {
    const wallet = new DialectSolanaWalletAdapterWrapper(
      this.solanaConfigProps.wallet
    );
    return {
      wallet
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA,
  DialectSolanaWalletAdapterWrapper,
  DialectWalletAdapterSolanaEd25519TokenSigner,
  NodeDialectSolanaWalletAdapter,
  SOLANA_ED25519_TOKEN_SIGNER_ALG,
  SOLANA_ED25519_TOKEN_SIGNER_ALG_BACKWARD_COMPATIBLE,
  SolanaEd25519AuthenticationFacadeFactory,
  SolanaEd25519TokenSigner,
  SolanaSdkFactory,
  SolanaTxAuthenticationFacadeFactory
});
//# sourceMappingURL=index.cjs.map