// src/wallet-adapter/dialect-solana-wallet-adapter-wrapper.ts
import { UnsupportedOperationError } from "@dialectlabs/sdk";
var DialectSolanaWalletAdapterWrapper = class _DialectSolanaWalletAdapterWrapper {
  constructor(delegate) {
    this.delegate = delegate;
  }
  get publicKey() {
    if (!this.delegate.publicKey) {
      throw new UnsupportedOperationError(
        "Public key not available",
        "Wallet does not have public key, please provide a valid public key."
      );
    }
    return this.delegate.publicKey;
  }
  get canEncrypt() {
    return Boolean(this.publicKey && this.delegate.diffieHellman);
  }
  static create(adapter) {
    return new _DialectSolanaWalletAdapterWrapper(adapter);
  }
  signTransaction(transaction) {
    if (!this.delegate.signTransaction) {
      throw new UnsupportedOperationError(
        "Signing not supported",
        "Wallet does not support signing, please use wallet-adapter that supports signTransaction() operation."
      );
    }
    return this.delegate.signTransaction(transaction);
  }
  signAllTransactions(transactions) {
    if (!this.delegate.signAllTransactions) {
      throw new UnsupportedOperationError(
        "Signing not supported",
        "Wallet does not support signing, please use wallet-adapter that supports signAllTransactions() operation."
      );
    }
    return this.delegate.signAllTransactions(transactions);
  }
  signMessage(message) {
    if (!this.delegate.signMessage) {
      throw new UnsupportedOperationError(
        "Message signing not supported",
        "Wallet does not support message signing, please use wallet-adapter that supports signMessage() operation."
      );
    }
    return this.delegate.signMessage(message);
  }
  diffieHellman() {
    if (!this.delegate.diffieHellman) {
      throw new UnsupportedOperationError(
        "Encryption not supported",
        "Wallet does not support encryption, please use wallet-adapter that supports diffieHellman() operation."
      );
    }
    return this.delegate.diffieHellman(this.publicKey.toBytes());
  }
  canSignMessage() {
    return Boolean(this.delegate.signMessage);
  }
  canSignTransaction() {
    return Boolean(this.delegate.signTransaction);
  }
};

// src/wallet-adapter/node-dialect-solana-wallet-adapter.ts
import {
  Keypair,
  VersionedTransaction
} from "@solana/web3.js";
import nacl from "tweetnacl";
import ed2curve from "ed2curve";
var NodeDialectSolanaWalletAdapter = class _NodeDialectSolanaWalletAdapter {
  constructor(keypair) {
    this.keypair = keypair;
  }
  get publicKey() {
    return this.keypair.publicKey;
  }
  static create(keypair) {
    if (keypair) {
      console.log(
        `Initializing ${_NodeDialectSolanaWalletAdapter.name} using provided ${keypair.publicKey.toBase58()} key.`
      );
      return new _NodeDialectSolanaWalletAdapter(keypair);
    } else if (process.env.DIALECT_SDK_CREDENTIALS) {
      const privateKey = process.env.DIALECT_SDK_CREDENTIALS;
      const keypair2 = Keypair.fromSecretKey(
        new Uint8Array(JSON.parse(privateKey))
      );
      console.log(
        `Initializing ${_NodeDialectSolanaWalletAdapter.name} using env-provided ${keypair2.publicKey.toBase58()} key.`
      );
      return new _NodeDialectSolanaWalletAdapter(keypair2);
    } else {
      throw new Error(
        `Error initializing ${_NodeDialectSolanaWalletAdapter.name}: SDK credential must be provided.`
      );
    }
  }
  async signTransaction(transaction) {
    if (transaction instanceof VersionedTransaction) {
      const signer = {
        publicKey: this.keypair.publicKey,
        secretKey: this.keypair.secretKey
      };
      const signers = [signer];
      transaction.sign(signers);
    } else {
      transaction.partialSign(this.keypair);
    }
    return transaction;
  }
  async signAllTransactions(transactions) {
    return Promise.all(transactions.map((tx) => this.signTransaction(tx)));
  }
  signMessage(message) {
    return Promise.resolve(nacl.sign.detached(message, this.keypair.secretKey));
  }
  diffieHellman(publicKey) {
    const keypair = ed2curve.convertKeyPair({
      secretKey: this.keypair.secretKey,
      publicKey
    });
    if (!keypair) {
      throw new Error("Failed to convert keypair");
    }
    return Promise.resolve(keypair);
  }
};

// src/auth/ed25519/solana-ed25519-authentication-facade-factory.ts
import {
  AuthenticationFacade,
  AuthenticationFacadeFactory,
  Authenticator,
  DefaultTokenGenerator,
  Ed25519TokenBodyParser,
  TokenParser
} from "@dialectlabs/sdk";

// src/auth/ed25519/solana-ed25519-token-validator.ts
import { Ed25519PublicKey, TokenValidator } from "@dialectlabs/sdk";
import nacl2 from "tweetnacl";

// src/sdk/constants.ts
var DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA = "solana";

// src/auth/ed25519/solana-ed25519-token-signer.ts
var SOLANA_ED25519_TOKEN_SIGNER_ALG = `${DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA}-ed25519`;
var SOLANA_ED25519_TOKEN_SIGNER_ALG_BACKWARD_COMPATIBLE = "ed25519";
var SolanaEd25519TokenSigner = class {
  constructor() {
    this.alg = SOLANA_ED25519_TOKEN_SIGNER_ALG;
  }
};
var DialectWalletAdapterSolanaEd25519TokenSigner = class extends SolanaEd25519TokenSigner {
  constructor(dialectWalletAdapter) {
    super();
    this.dialectWalletAdapter = dialectWalletAdapter;
  }
  get subject() {
    return this.dialectWalletAdapter.publicKey.toBase58();
  }
  get subjectPublicKey() {
    return this.dialectWalletAdapter.publicKey;
  }
  async sign(payload) {
    return {
      payload,
      signature: await this.dialectWalletAdapter.signMessage(payload)
    };
  }
};

// src/auth/ed25519/solana-ed25519-token-validator.ts
var SolanaEd25519TokenValidator = class extends TokenValidator {
  canValidate(tokenHeader) {
    return tokenHeader.alg === SOLANA_ED25519_TOKEN_SIGNER_ALG || tokenHeader.alg === SOLANA_ED25519_TOKEN_SIGNER_ALG_BACKWARD_COMPATIBLE;
  }
  isSignatureValid(token) {
    const signedPayload = token.base64Header + "." + token.base64Body;
    const signingPayload = new TextEncoder().encode(signedPayload);
    return nacl2.sign.detached.verify(
      signingPayload,
      token.signature,
      new Ed25519PublicKey(token.body.sub_jwk ?? token.body.sub).toBytes()
    );
  }
  performExtraValidation(token) {
    if (!token.body.sub_jwk) {
      return true;
    }
    return token.body.sub === token.body.sub_jwk;
  }
};

// src/auth/ed25519/solana-ed25519-authentication-facade-factory.ts
var SolanaEd25519AuthenticationFacadeFactory = class _SolanaEd25519AuthenticationFacadeFactory extends AuthenticationFacadeFactory {
  constructor(tokenSigner) {
    super();
    this.tokenSigner = tokenSigner;
  }
  static createAuthenticator() {
    return new Authenticator(
      new TokenParser(new Ed25519TokenBodyParser()),
      new SolanaEd25519TokenValidator()
    );
  }
  get() {
    return new AuthenticationFacade(
      this.tokenSigner,
      new DefaultTokenGenerator(this.tokenSigner),
      _SolanaEd25519AuthenticationFacadeFactory.createAuthenticator()
    );
  }
};

// src/auth/tx/solana-tx-authentication-facade-factory.ts
import {
  AuthenticationFacade as AuthenticationFacade2,
  AuthenticationFacadeFactory as AuthenticationFacadeFactory2,
  Authenticator as Authenticator2,
  TokenParser as TokenParser2
} from "@dialectlabs/sdk";

// src/auth/tx/solana-tx-token-body-parser.ts
import {
  bytesFromBase64,
  jsonParseFromBase64,
  TokenBodyParser,
  TokenStructureValidationError
} from "@dialectlabs/sdk";
import { Transaction as Transaction2 } from "@solana/web3.js";
var SolanaTxTokenBodyParser = class extends TokenBodyParser {
  parse(base64Body) {
    const byteBody = bytesFromBase64(base64Body);
    const tx = Transaction2.from(byteBody);
    const dataInstruction = tx.instructions.filter(
      (it) => it.programId === tx.feePayer
    )[0];
    if (!dataInstruction) {
      throw new TokenStructureValidationError();
    }
    const [headerBase64, bodyBase64] = dataInstruction.data.toString().split(".");
    if (!headerBase64 || !bodyBase64) {
      throw new TokenStructureValidationError();
    }
    return jsonParseFromBase64(bodyBase64);
  }
};

// src/auth/tx/solana-tx-token-generator.ts
import {
  bytesToBase64,
  jsonStringifyToBase64,
  TokenGenerator
} from "@dialectlabs/sdk";
var SolanaTxTokenGenerator = class extends TokenGenerator {
  async generate(ttlSeconds) {
    const header = this.header();
    const base64Header = jsonStringifyToBase64(header);
    const body = this.body(ttlSeconds);
    const base64Body = jsonStringifyToBase64(body);
    const { signature, base64Signature, signedPayload } = await this.sign(
      base64Header,
      base64Body,
      this.signer
    );
    const base64SignedBody = bytesToBase64(signedPayload);
    const rawValue = `${base64Header}.${base64SignedBody}.${base64Signature}`;
    return {
      rawValue,
      body,
      header,
      signature,
      base64Signature,
      base64Body: base64SignedBody,
      base64Header
    };
  }
};

// src/auth/tx/solana-tx-token-validator.ts
import { decodeURLSafe } from "@stablelib/base64";
import { PublicKey as PublicKey2, Transaction as Transaction4 } from "@solana/web3.js";
import { TokenValidator as TokenValidator2 } from "@dialectlabs/sdk";

// src/auth/tx/solana-tx-token-signer.ts
import {
  PublicKey as SolanaPublicKey,
  Transaction as Transaction3,
  TransactionInstruction
} from "@solana/web3.js";
var SOLANA_TX_TOKEN_SIGNER_ALG = `${DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA}-tx`;
var SolanaTxTokenSigner = class {
  constructor() {
    this.alg = SOLANA_TX_TOKEN_SIGNER_ALG;
  }
};
var DialectWalletAdapterSolanaTxTokenSigner = class extends SolanaTxTokenSigner {
  constructor(dialectWalletAdapter) {
    super();
    this.dialectWalletAdapter = dialectWalletAdapter;
  }
  get subject() {
    return this.dialectWalletAdapter.publicKey.toBase58();
  }
  get subjectPublicKey() {
    return this.dialectWalletAdapter.publicKey;
  }
  async sign(payload) {
    const tx = new Transaction3();
    const subjectPublicKey = new SolanaPublicKey(this.subject);
    tx.add(
      new TransactionInstruction({
        keys: [
          {
            pubkey: subjectPublicKey,
            isSigner: false,
            isWritable: false
          }
        ],
        programId: subjectPublicKey,
        data: Buffer.from(payload)
      })
    );
    tx.recentBlockhash = SolanaPublicKey.default.toString();
    tx.feePayer = subjectPublicKey;
    const signedTx = await this.dialectWalletAdapter.signTransaction(tx);
    return {
      payload: signedTx.serialize(),
      signature: signedTx.signature
    };
  }
};

// src/auth/tx/solana-tx-token-validator.ts
var SolanaTxTokenValidator = class extends TokenValidator2 {
  canValidate(tokenHeader) {
    return tokenHeader.alg === SOLANA_TX_TOKEN_SIGNER_ALG;
  }
  isSignatureValid(token) {
    const byteBody = decodeURLSafe(token.base64Body);
    const tx = Transaction4.from(byteBody);
    tx.recentBlockhash = PublicKey2.default.toString();
    return tx.verifySignatures();
  }
  performExtraValidation(token) {
    if (!token.body.sub_jwk) {
      return true;
    }
    return token.body.sub === token.body.sub_jwk;
  }
};

// src/auth/tx/solana-tx-authentication-facade-factory.ts
var SolanaTxAuthenticationFacadeFactory = class _SolanaTxAuthenticationFacadeFactory extends AuthenticationFacadeFactory2 {
  constructor(tokenSigner) {
    super();
    this.tokenSigner = tokenSigner;
  }
  static createAuthenticator() {
    return new Authenticator2(
      new TokenParser2(new SolanaTxTokenBodyParser()),
      new SolanaTxTokenValidator()
    );
  }
  get() {
    return new AuthenticationFacade2(
      this.tokenSigner,
      new SolanaTxTokenGenerator(this.tokenSigner),
      _SolanaTxAuthenticationFacadeFactory.createAuthenticator()
    );
  }
};

// src/sdk/sdk.ts
import { EncryptionKeysProvider as EncryptionKeysProvider2 } from "@dialectlabs/sdk";

// src/encryption/encryption-keys-provider.ts
import { EncryptionKeysProvider } from "@dialectlabs/sdk";
var DialectSolanaWalletAdapterEncryptionKeysProvider = class extends EncryptionKeysProvider {
  constructor(dialectWalletAdapter) {
    super();
    this.dialectWalletAdapter = dialectWalletAdapter;
  }
  isAvailable() {
    return this.dialectWalletAdapter.canEncrypt;
  }
  getFailSafe() {
    return this.dialectWalletAdapter.canEncrypt ? this.dialectWalletAdapter.diffieHellman() : Promise.resolve(null);
  }
  getFailFast() {
    return this.dialectWalletAdapter.diffieHellman();
  }
};

// src/sdk/sdk.ts
var SolanaSdkFactory = class _SolanaSdkFactory {
  constructor(solanaConfigProps) {
    this.solanaConfigProps = solanaConfigProps;
  }
  static create(props) {
    return new _SolanaSdkFactory(props);
  }
  static logConfiguration(config, environment) {
    if (environment !== "production") {
      console.log(
        `Initializing Dialect Solana SDK using configuration:
Solana settings:
  Wallet public key: ${config.wallet.publicKey}
  Wallet supports encryption: ${config.wallet.canEncrypt}
  Wallet supports authentication: ${config.wallet.canSignMessage() || config.wallet.canSignTransaction()}
`
      );
    }
  }
  create(config) {
    const solanaConfig = this.initializeSolanaConfig();
    const wallet = solanaConfig.wallet;
    _SolanaSdkFactory.logConfiguration(solanaConfig, config.environment);
    const walletAdapterEncryptionKeysProvider = new DialectSolanaWalletAdapterEncryptionKeysProvider(wallet);
    const encryptionKeysProvider = EncryptionKeysProvider2.create(
      walletAdapterEncryptionKeysProvider,
      config.encryptionKeysStore
    );
    const authenticationFacadeFactory = wallet.canSignMessage() ? new SolanaEd25519AuthenticationFacadeFactory(
      new DialectWalletAdapterSolanaEd25519TokenSigner(wallet)
    ) : new SolanaTxAuthenticationFacadeFactory(
      new DialectWalletAdapterSolanaTxTokenSigner(wallet)
    );
    const authenticationFacade = authenticationFacadeFactory.get();
    return {
      type: DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA,
      encryptionKeysProvider,
      authenticationFacade,
      config: solanaConfig,
      info: {
        supportsOnChainMessaging: false
      }
    };
  }
  initializeSolanaConfig() {
    const wallet = new DialectSolanaWalletAdapterWrapper(
      this.solanaConfigProps.wallet
    );
    return {
      wallet
    };
  }
};
export {
  DIALECT_BLOCKCHAIN_SDK_TYPE_SOLANA,
  DialectSolanaWalletAdapterWrapper,
  DialectWalletAdapterSolanaEd25519TokenSigner,
  NodeDialectSolanaWalletAdapter,
  SOLANA_ED25519_TOKEN_SIGNER_ALG,
  SOLANA_ED25519_TOKEN_SIGNER_ALG_BACKWARD_COMPATIBLE,
  SolanaEd25519AuthenticationFacadeFactory,
  SolanaEd25519TokenSigner,
  SolanaSdkFactory,
  SolanaTxAuthenticationFacadeFactory
};
//# sourceMappingURL=index.js.map