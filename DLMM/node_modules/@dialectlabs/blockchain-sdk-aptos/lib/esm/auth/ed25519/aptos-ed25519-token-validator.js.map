{"version":3,"file":"aptos-ed25519-token-validator.js","sourceRoot":"","sources":["../../../../src/auth/ed25519/aptos-ed25519-token-validator.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAC;AAEjC,OAAO,EAAE,8BAA8B,EAAE,MAAM,8BAA8B,CAAC;AAC9E,OAAO,EAAE,sBAAsB,EAAE,MAAM,iCAAiC,CAAC;AACzE,OAAO,EACL,mBAAmB,EAGnB,cAAc,GACf,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAAE,SAAS,EAAE,MAAM,OAAO,CAAC;AAClC,OAAO,EAAE,uBAAuB,EAAE,MAAM,oCAAoC,CAAC;AAE7E,MAAM,OAAO,0BAA2B,SAAQ,cAAc;IAC5D,WAAW,CAAC,WAAwB;QAClC,OAAO,WAAW,CAAC,GAAG,KAAK,8BAA8B,CAAC;IAC5D,CAAC;IAEQ,gBAAgB,CAAC,KAAY;QACpC,MAAM,aAAa,GAAG,KAAK,CAAC,YAAY,GAAG,GAAG,GAAG,KAAK,CAAC,UAAU,CAAC;QAClE,MAAM,cAAc,GAAG,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;QAC/D,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CACzB,cAAc,EACd,KAAK,CAAC,SAAS,EACf,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CACzB,CAAC;IACJ,CAAC;IAEQ,sBAAsB,CAAC,KAAY;QAC1C,MAAM,OAAO,GAAG,sBAAsB,CACpC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CACnD,CAAC,QAAQ,EAAE,CAAC;QACb,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,MAAM,CAAC,OAAO,CAAC,CAAC;IACpD,CAAC;IAEO,YAAY,CAAC,KAAY;QAC/B,MAAM,eAAe,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC;QAC3C,IAAI,CAAC,eAAe,EAAE;YACpB,MAAM,IAAI,mBAAmB,CAC3B,6CAA6C,CAC9C,CAAC;SACH;QACD,MAAM,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;QACpD,OAAO,uBAAuB,CAAC,SAAS,CAAC,CAAC,YAAY,EAAE,CAAC;IAC3D,CAAC;CACF","sourcesContent":["import { sign } from 'tweetnacl';\n\nimport { APTOS_ED25519_TOKEN_SIGNER_ALG } from './aptos-ed25519-token-signer';\nimport { getAptosAccountAddress } from '../../utils/aptos-account-utils';\nimport {\n  AuthenticationError,\n  Token,\n  TokenHeader,\n  TokenValidator,\n} from '@dialectlabs/sdk';\nimport { HexString } from 'aptos';\nimport { getPublicKeyWithPadding } from '../../utils/aptos-public-key-utils';\n\nexport class AptosEd25519TokenValidator extends TokenValidator {\n  canValidate(tokenHeader: TokenHeader): boolean {\n    return tokenHeader.alg === APTOS_ED25519_TOKEN_SIGNER_ALG;\n  }\n\n  override isSignatureValid(token: Token): boolean {\n    const signedPayload = token.base64Header + '.' + token.base64Body;\n    const signingPayload = new TextEncoder().encode(signedPayload);\n    return sign.detached.verify(\n      signingPayload,\n      token.signature,\n      this.getPublicKey(token),\n    );\n  }\n\n  override performExtraValidation(token: Token): boolean {\n    const address = getAptosAccountAddress(\n      HexString.fromUint8Array(this.getPublicKey(token)),\n    ).toString();\n    return BigInt(token.body.sub) === BigInt(address);\n  }\n\n  private getPublicKey(token: Token): Uint8Array {\n    const signerPublicKey = token.body.sub_jwk;\n    if (!signerPublicKey) {\n      throw new AuthenticationError(\n        'Cannot validate token without sub_jwk claim',\n      );\n    }\n    const hexPubKey = HexString.ensure(signerPublicKey);\n    return getPublicKeyWithPadding(hexPubKey).toUint8Array();\n  }\n}\n"]}