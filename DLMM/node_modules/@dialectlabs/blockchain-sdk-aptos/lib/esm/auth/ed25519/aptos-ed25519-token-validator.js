import { sign } from 'tweetnacl';
import { APTOS_ED25519_TOKEN_SIGNER_ALG } from './aptos-ed25519-token-signer';
import { getAptosAccountAddress } from '../../utils/aptos-account-utils';
import { AuthenticationError, TokenValidator, } from '@dialectlabs/sdk';
import { HexString } from 'aptos';
import { getPublicKeyWithPadding } from '../../utils/aptos-public-key-utils';
export class AptosEd25519TokenValidator extends TokenValidator {
    canValidate(tokenHeader) {
        return tokenHeader.alg === APTOS_ED25519_TOKEN_SIGNER_ALG;
    }
    isSignatureValid(token) {
        const signedPayload = token.base64Header + '.' + token.base64Body;
        const signingPayload = new TextEncoder().encode(signedPayload);
        return sign.detached.verify(signingPayload, token.signature, this.getPublicKey(token));
    }
    performExtraValidation(token) {
        const address = getAptosAccountAddress(HexString.fromUint8Array(this.getPublicKey(token))).toString();
        return BigInt(token.body.sub) === BigInt(address);
    }
    getPublicKey(token) {
        const signerPublicKey = token.body.sub_jwk;
        if (!signerPublicKey) {
            throw new AuthenticationError('Cannot validate token without sub_jwk claim');
        }
        const hexPubKey = HexString.ensure(signerPublicKey);
        return getPublicKeyWithPadding(hexPubKey).toUint8Array();
    }
}
//# sourceMappingURL=aptos-ed25519-token-validator.js.map