"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosEd25519TokenValidator = void 0;
const tweetnacl_1 = require("tweetnacl");
const aptos_ed25519_token_signer_1 = require("./aptos-ed25519-token-signer");
const aptos_account_utils_1 = require("../../utils/aptos-account-utils");
const sdk_1 = require("@dialectlabs/sdk");
const aptos_1 = require("aptos");
const aptos_public_key_utils_1 = require("../../utils/aptos-public-key-utils");
class AptosEd25519TokenValidator extends sdk_1.TokenValidator {
    canValidate(tokenHeader) {
        return tokenHeader.alg === aptos_ed25519_token_signer_1.APTOS_ED25519_TOKEN_SIGNER_ALG;
    }
    isSignatureValid(token) {
        const signedPayload = token.base64Header + '.' + token.base64Body;
        const signingPayload = new TextEncoder().encode(signedPayload);
        return tweetnacl_1.sign.detached.verify(signingPayload, token.signature, this.getPublicKey(token));
    }
    performExtraValidation(token) {
        const address = (0, aptos_account_utils_1.getAptosAccountAddress)(aptos_1.HexString.fromUint8Array(this.getPublicKey(token))).toString();
        return BigInt(token.body.sub) === BigInt(address);
    }
    getPublicKey(token) {
        const signerPublicKey = token.body.sub_jwk;
        if (!signerPublicKey) {
            throw new sdk_1.AuthenticationError('Cannot validate token without sub_jwk claim');
        }
        const hexPubKey = aptos_1.HexString.ensure(signerPublicKey);
        return (0, aptos_public_key_utils_1.getPublicKeyWithPadding)(hexPubKey).toUint8Array();
    }
}
exports.AptosEd25519TokenValidator = AptosEd25519TokenValidator;
//# sourceMappingURL=aptos-ed25519-token-validator.js.map