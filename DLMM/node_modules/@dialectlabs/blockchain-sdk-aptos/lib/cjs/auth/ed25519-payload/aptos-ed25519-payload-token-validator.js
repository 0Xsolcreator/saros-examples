"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosEd25519PayloadTokenValidator = void 0;
const tweetnacl_1 = require("tweetnacl");
const aptos_ed25519_payload_token_signer_1 = require("./aptos-ed25519-payload-token-signer");
const aptos_account_utils_1 = require("../../utils/aptos-account-utils");
const aptos_public_key_utils_1 = require("../../utils/aptos-public-key-utils");
const sdk_1 = require("@dialectlabs/sdk");
const aptos_1 = require("aptos");
const base64_1 = require("@stablelib/base64");
class AptosEd25519PayloadTokenValidator extends sdk_1.TokenValidator {
    canValidate(tokenHeader) {
        return tokenHeader.alg === aptos_ed25519_payload_token_signer_1.APTOS_ED25519_PAYLOAD_TOKEN_SIGNER_ALG;
    }
    isSignatureValid(token) {
        const signedPayload = (0, base64_1.decodeURLSafe)(token.base64Body);
        return tweetnacl_1.sign.detached.verify(signedPayload, token.signature, this.getPublicKey(token));
    }
    performExtraValidation(token) {
        const address = (0, aptos_account_utils_1.getAptosAccountAddress)(aptos_1.HexString.fromUint8Array(this.getPublicKey(token))).toString();
        return BigInt(token.body.sub) === BigInt(address);
    }
    getPublicKey(token) {
        const signerPublicKey = token.body.sub_jwk;
        if (!signerPublicKey) {
            throw new sdk_1.AuthenticationError('Cannot validate token without sub_jwk claim');
        }
        const hexPubKey = aptos_1.HexString.ensure(signerPublicKey);
        return (0, aptos_public_key_utils_1.getPublicKeyWithPadding)(hexPubKey).toUint8Array();
    }
}
exports.AptosEd25519PayloadTokenValidator = AptosEd25519PayloadTokenValidator;
//# sourceMappingURL=aptos-ed25519-payload-token-validator.js.map