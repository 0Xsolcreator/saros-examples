"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefineDataSourceStepImpl = exports.ChooseDataSourceStepImpl = exports.MonitorsBuilderState = void 0;
const luxon_1 = require("luxon");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const monitor_api_1 = require("../monitor-api");
const dialect_thread_notification_sink_1 = require("../dialect-thread-notification-sink");
const sengrid_email_notification_sink_1 = require("../sengrid-email-notification-sink");
const twilio_sms_notification_sink_1 = require("../twilio-sms-notification-sink");
const telegram_notification_sink_1 = require("../telegram-notification-sink");
const solflare_notification_sink_1 = require("../solflare-notification-sink");
const dialect_sdk_notification_sink_1 = require("../dialect-sdk-notification-sink");
const subscriber_repository_factory_1 = require("./subscriber-repository-factory");
const notification_type_eligibility_predicate_1 = require("./notification-type-eligibility-predicate");
/**
 * A set of factory methods to create monitors
 */
class MonitorsBuilderState {
    static create(monitorProps) {
        const subscriberRepositoryFactory = new subscriber_repository_factory_1.SubscriberRepositoryFactory(monitorProps);
        return new MonitorsBuilderState(monitorProps, subscriberRepositoryFactory.create());
    }
    constructor(monitorProps, subscriberRepository) {
        this.subscriberRepository = subscriberRepository;
        this.notificationTypeEligibilityPredicate = notification_type_eligibility_predicate_1.NotificationTypeEligibilityPredicate.create();
        this.dialectNotificationSink =
            this.createDialectThreadNotificationSink(monitorProps);
        this.dialectSdkNotificationSink =
            this.createDialectSdkNotificationSink(monitorProps);
        const sinks = monitorProps === null || monitorProps === void 0 ? void 0 : monitorProps.sinks;
        if (sinks === null || sinks === void 0 ? void 0 : sinks.email) {
            this.emailNotificationSink = new sengrid_email_notification_sink_1.SengridEmailNotificationSink(sinks.email.apiToken, sinks.email.senderEmail, this.subscriberRepository, this.notificationTypeEligibilityPredicate);
        }
        if (sinks === null || sinks === void 0 ? void 0 : sinks.sms) {
            this.smsNotificationSink = new twilio_sms_notification_sink_1.TwilioSmsNotificationSink({
                username: sinks.sms.twilioUsername,
                password: sinks.sms.twilioPassword,
            }, sinks.sms.senderSmsNumber, this.subscriberRepository, this.notificationTypeEligibilityPredicate);
        }
        if (sinks === null || sinks === void 0 ? void 0 : sinks.telegram) {
            this.telegramNotificationSink = new telegram_notification_sink_1.TelegramNotificationSink(sinks.telegram.telegramBotToken, this.subscriberRepository, this.notificationTypeEligibilityPredicate);
        }
        if (sinks === null || sinks === void 0 ? void 0 : sinks.solflare) {
            this.solflareNotificationSink = new solflare_notification_sink_1.SolflareNotificationSink(sinks.solflare.apiKey, sinks.solflare.apiUrl);
        }
    }
    createDialectThreadNotificationSink(monitorProps) {
        var _a, _b;
        if ('sdk' in monitorProps) {
            return new dialect_thread_notification_sink_1.DialectThreadNotificationSink(monitorProps.sdk, this.subscriberRepository, this.notificationTypeEligibilityPredicate);
        }
        else {
            const sdk = (_b = (_a = monitorProps.sinks) === null || _a === void 0 ? void 0 : _a.dialect) === null || _b === void 0 ? void 0 : _b.sdk;
            return (sdk &&
                new dialect_thread_notification_sink_1.DialectThreadNotificationSink(sdk, this.subscriberRepository, this.notificationTypeEligibilityPredicate));
        }
    }
    createDialectSdkNotificationSink(monitorProps) {
        var _a, _b;
        if ('sdk' in monitorProps) {
            return new dialect_sdk_notification_sink_1.DialectSdkNotificationSink(monitorProps.sdk, this.subscriberRepository);
        }
        else {
            const sdk = (_b = (_a = monitorProps.sinks) === null || _a === void 0 ? void 0 : _a.dialect) === null || _b === void 0 ? void 0 : _b.sdk;
            return (sdk && new dialect_sdk_notification_sink_1.DialectSdkNotificationSink(sdk, this.subscriberRepository));
        }
    }
}
exports.MonitorsBuilderState = MonitorsBuilderState;
class ChooseDataSourceStepImpl {
    constructor(monitorProps) {
        this.monitorProps = monitorProps;
    }
    subscriberEvents() {
        this.dataSourceType = 'subscriber-events';
        const monitorsBuilderState = MonitorsBuilderState.create(this.monitorProps);
        monitorsBuilderState.chooseDataSourceStep = this;
        return new AddTransformationsStepImpl(monitorsBuilderState);
    }
    defineDataSource() {
        this.dataSourceType = 'user-defined';
        const monitorsBuilderState = MonitorsBuilderState.create(this.monitorProps);
        monitorsBuilderState.chooseDataSourceStep = this;
        return new DefineDataSourceStepImpl(monitorsBuilderState);
    }
}
exports.ChooseDataSourceStepImpl = ChooseDataSourceStepImpl;
class DefineDataSourceStepImpl {
    constructor(monitorBuilderState) {
        this.monitorBuilderState = monitorBuilderState;
        this.monitorBuilderState.defineDataSourceStep = this;
    }
    poll(dataSource, pollInterval) {
        this.pollableDataSource = dataSource;
        this.pollInterval = pollInterval;
        this.dataSourceStrategy = 'poll';
        return new AddTransformationsStepImpl(this.monitorBuilderState);
    }
    push(dataSource) {
        this.pushyDataSource = dataSource;
        this.dataSourceStrategy = 'push';
        return new AddTransformationsStepImpl(this.monitorBuilderState);
    }
}
exports.DefineDataSourceStepImpl = DefineDataSourceStepImpl;
class AddTransformationsStepImpl {
    constructor(monitorBuilderState) {
        this.monitorBuilderState = monitorBuilderState;
        this.dataSourceTransformationPipelines = [];
        monitorBuilderState.addTransformationsStep = this;
    }
    notify(metadata) {
        const identityTransformation = (dataSource) => dataSource;
        this.dataSourceTransformationPipelines.push(identityTransformation);
        return new AddSinksStepImpl(this, this.dataSourceTransformationPipelines, metadata, this.monitorBuilderState.dialectNotificationSink, this.monitorBuilderState.dialectSdkNotificationSink, this.monitorBuilderState.emailNotificationSink, this.monitorBuilderState.smsNotificationSink, this.monitorBuilderState.telegramNotificationSink, this.monitorBuilderState.solflareNotificationSink);
    }
    transform(transformation) {
        const dataSourceTransformationPipelines = [];
        const { keys, pipelines } = transformation;
        const adaptedToDataSourceTypePipelines = keys.flatMap((key) => pipelines.map((pipeline) => {
            const adaptedToDataSourceType = (dataSource) => pipeline(dataSource.pipe((0, operators_1.map)((it) => ({
                ...it,
                value: it.value[key],
            }))));
            return adaptedToDataSourceType;
        }));
        dataSourceTransformationPipelines.push(...adaptedToDataSourceTypePipelines);
        return new NotifyStepImpl(this, dataSourceTransformationPipelines, this.monitorBuilderState);
    }
}
class NotifyStepImpl {
    constructor(addTransformationsStep, dataSourceTransformationPipelines, monitorBuilderState) {
        this.addTransformationsStep = addTransformationsStep;
        this.dataSourceTransformationPipelines = dataSourceTransformationPipelines;
        this.monitorBuilderState = monitorBuilderState;
    }
    notify(metadata) {
        return new AddSinksStepImpl(this.addTransformationsStep, this.dataSourceTransformationPipelines, metadata, this.monitorBuilderState.dialectNotificationSink, this.monitorBuilderState.dialectSdkNotificationSink, this.monitorBuilderState.emailNotificationSink, this.monitorBuilderState.smsNotificationSink, this.monitorBuilderState.telegramNotificationSink, this.monitorBuilderState.solflareNotificationSink);
    }
}
class AddSinksStepImpl {
    constructor(addTransformationsStep, dataSourceTransformationPipelines, notificationMetadata, dialectNotificationSink, dialectSdkNotificationSink, emailNotificationSink, smsNotificationSink, telegramNotificationSink, solflareNotificationSink) {
        this.addTransformationsStep = addTransformationsStep;
        this.dataSourceTransformationPipelines = dataSourceTransformationPipelines;
        this.notificationMetadata = notificationMetadata;
        this.dialectNotificationSink = dialectNotificationSink;
        this.dialectSdkNotificationSink = dialectSdkNotificationSink;
        this.emailNotificationSink = emailNotificationSink;
        this.smsNotificationSink = smsNotificationSink;
        this.telegramNotificationSink = telegramNotificationSink;
        this.solflareNotificationSink = solflareNotificationSink;
        this.sinkWriters = [];
    }
    also() {
        this.populateDataSourceTransformationPipelines();
        return this.addTransformationsStep;
    }
    dialectThread(adapter, dispatchStrategy) {
        if (!this.dialectNotificationSink) {
            throw new Error('Dialect notification sink must be initialized before using');
        }
        return this.custom(adapter, this.dialectNotificationSink, dispatchStrategy);
    }
    dialectSdk(adapter, dispatchStrategy) {
        if (!this.dialectSdkNotificationSink) {
            throw new Error('Dialect Cloud notification sink must be initialized before using');
        }
        return this.custom(adapter, this.dialectSdkNotificationSink, dispatchStrategy);
    }
    custom(adapter, sink, dispatchStrategy) {
        const sinkWriter = (data) => {
            const toBeNotified = this.selectResources(dispatchStrategy, data);
            return sink.push(adapter(data), toBeNotified, {
                dispatchType: dispatchStrategy.dispatch,
                notificationMetadata: this.notificationMetadata,
            });
        };
        this.sinkWriters.push(sinkWriter);
        return this;
    }
    email(adapter, dispatchStrategy) {
        if (!this.emailNotificationSink) {
            throw new Error('Email notification sink must be initialized before using');
        }
        return this.custom(adapter, this.emailNotificationSink, dispatchStrategy);
    }
    sms(adapter, dispatchStrategy) {
        if (!this.smsNotificationSink) {
            throw new Error('SMS notification sink must be initialized before using');
        }
        return this.custom(adapter, this.smsNotificationSink, dispatchStrategy);
    }
    telegram(adapter, dispatchStrategy) {
        if (!this.telegramNotificationSink) {
            throw new Error('Telegram notification sink must be initialized before using');
        }
        return this.custom(adapter, this.telegramNotificationSink, dispatchStrategy);
    }
    solflare(adapter, dispatchStrategy) {
        if (!this.solflareNotificationSink) {
            throw new Error('Solflare notification sink must be initialized before using');
        }
        return this.custom(adapter, this.solflareNotificationSink, dispatchStrategy);
    }
    and() {
        this.populateDataSourceTransformationPipelines();
        return new BuildStepImpl(this.addTransformationsStep.monitorBuilderState);
    }
    populateDataSourceTransformationPipelines() {
        const transformAndLoadPipelines = this.dataSourceTransformationPipelines.map((dataSourceTransformationPipeline) => {
            const transformAndLoadPipeline = (dataSource) => dataSourceTransformationPipeline(dataSource).pipe((0, rxjs_1.exhaustMap)((event) => (0, rxjs_1.from)(Promise.all(this.sinkWriters.map((it) => it(event))))));
            return transformAndLoadPipeline;
        });
        this.addTransformationsStep.dataSourceTransformationPipelines.push(...transformAndLoadPipelines);
    }
    selectResources(dispatchStrategy, { context }) {
        switch (dispatchStrategy.dispatch) {
            case 'broadcast': {
                return context.subscribers.map(({ resourceId }) => resourceId);
            }
            case 'unicast': {
                return [dispatchStrategy.to(context)];
            }
            case 'multicast': {
                return dispatchStrategy.to(context);
            }
        }
    }
}
class BuildStepImpl {
    constructor(monitorBuilderState) {
        this.monitorBuilderState = monitorBuilderState;
    }
    build() {
        const { subscriberRepository, chooseDataSourceStep, defineDataSourceStep, addTransformationsStep, } = this.monitorBuilderState;
        if (!chooseDataSourceStep || !addTransformationsStep) {
            throw new Error('Expected [monitorProps, chooseDataSourceStep, addTransformationsStep] to be defined');
        }
        switch (chooseDataSourceStep.dataSourceType) {
            case 'user-defined': {
                if (!defineDataSourceStep) {
                    throw new Error('Expected data source to be defined');
                }
                return this.createUserDefinedMonitor(defineDataSourceStep, addTransformationsStep, subscriberRepository);
            }
            case 'subscriber-events': {
                return this.buildSubscriberEventMonitor(addTransformationsStep, subscriberRepository);
            }
            default: {
                throw new Error(`Unexpected data source type: ${chooseDataSourceStep.dataSourceType}`);
            }
        }
    }
    buildSubscriberEventMonitor(addTransformationsStep, subscriberRepository) {
        const { dataSourceTransformationPipelines } = addTransformationsStep;
        if (!dataSourceTransformationPipelines) {
            throw new Error('Expected [dataSourceTransformationPipelines] to be defined');
        }
        return monitor_api_1.Monitors.factory(subscriberRepository).createSubscriberEventMonitor(dataSourceTransformationPipelines);
    }
    createUserDefinedMonitor(defineDataSourceStep, addTransformationsStep, subscriberRepository) {
        const { dataSourceStrategy } = defineDataSourceStep;
        switch (dataSourceStrategy) {
            case 'poll':
                return this.createForPollable(defineDataSourceStep, addTransformationsStep, subscriberRepository);
            case 'push':
                return this.createForPushy(defineDataSourceStep, addTransformationsStep, subscriberRepository);
            default:
                throw new Error('Expected data source strategy to be defined');
        }
    }
    createForPollable(defineDataSourceStep, addTransformationsStep, subscriberRepository) {
        const { pollableDataSource, pollInterval } = defineDataSourceStep;
        const { dataSourceTransformationPipelines } = addTransformationsStep;
        if (!pollableDataSource ||
            !pollInterval ||
            !dataSourceTransformationPipelines) {
            throw new Error('Expected [pollableDataSource, pollInterval, dataSourceTransformationPipelines] to be defined');
        }
        return monitor_api_1.Monitors.factory(subscriberRepository).createDefaultMonitor(pollableDataSource, dataSourceTransformationPipelines, pollInterval);
    }
    createForPushy(defineDataSourceStep, addTransformationsStep, subscriberRepository) {
        const { pushyDataSource } = defineDataSourceStep;
        const { dataSourceTransformationPipelines } = addTransformationsStep;
        if (!pushyDataSource || !dataSourceTransformationPipelines) {
            throw new Error('Expected [pushyDataSource, dataSourceTransformationPipelines] to be defined');
        }
        return monitor_api_1.Monitors.factory(subscriberRepository).createDefaultMonitor(pushyDataSource, dataSourceTransformationPipelines, luxon_1.Duration.fromObject({ seconds: 1 }));
    }
}
