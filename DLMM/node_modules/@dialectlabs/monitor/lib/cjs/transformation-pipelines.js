"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pipelines = void 0;
const transformation_pipeline_operators_1 = require("./transformation-pipeline-operators");
function createTriggerOperator(trigger) {
    switch (trigger.type) {
        case 'falling-edge':
            return transformation_pipeline_operators_1.Operators.Trigger.fallingEdge(trigger.threshold, trigger.limit);
        case 'rising-edge':
            return transformation_pipeline_operators_1.Operators.Trigger.risingEdge(trigger.threshold, trigger.limit);
        case 'increase':
            return transformation_pipeline_operators_1.Operators.Trigger.increase(trigger.threshold);
        case 'decrease':
            return transformation_pipeline_operators_1.Operators.Trigger.decrease(trigger.threshold);
    }
    throw new Error('Should not happen');
}
class Pipelines {
    static change(compareBy, rateLimit) {
        return Pipelines.createNew((upstream) => upstream
            .pipe(transformation_pipeline_operators_1.Operators.Window.fixedSizeSliding(2))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.filter((it) => it.length === 2))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.filter(([d1, d2]) => !compareBy(d1.value, d2.value)))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.map(([d1, d2]) => {
            const change = {
                prev: d1.value,
                current: d2.value,
            };
            const data = {
                value: change,
                context: d2.context,
            };
            return data;
        }))
            .pipe(rateLimit
            ? transformation_pipeline_operators_1.Operators.FlowControl.rateLimit(rateLimit.timeSpan)
            : transformation_pipeline_operators_1.Operators.Transform.identity()));
    }
    static added(compareBy, rateLimit) {
        return Pipelines.createNew((upstream) => upstream
            .pipe(transformation_pipeline_operators_1.Operators.Window.fixedSizeSliding(2))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.filter((it) => it.length === 2))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.map(([d1, d2]) => {
            const added = d2.value.filter((e2) => !d1.value.find((e1) => compareBy(e1, e2)));
            const data = {
                value: added,
                context: d2.context,
            };
            return data;
        }))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.filter(({ value: added }) => added.length > 0))
            .pipe(rateLimit
            ? transformation_pipeline_operators_1.Operators.FlowControl.rateLimit(rateLimit.timeSpan)
            : transformation_pipeline_operators_1.Operators.Transform.identity()));
    }
    static removed(compareBy, rateLimit) {
        return Pipelines.createNew((upstream) => upstream
            .pipe(transformation_pipeline_operators_1.Operators.Window.fixedSizeSliding(2))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.filter((it) => it.length === 2))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.map(([d1, d2]) => {
            const removed = d1.value.filter((e1) => !d2.value.find((e2) => compareBy(e1, e2)));
            const data = {
                value: removed,
                context: d2.context,
            };
            return data;
        }))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.filter(({ value: added }) => added.length > 0))
            .pipe(rateLimit
            ? transformation_pipeline_operators_1.Operators.FlowControl.rateLimit(rateLimit.timeSpan)
            : transformation_pipeline_operators_1.Operators.Transform.identity()));
    }
    static diff(compareBy, rateLimit) {
        return Pipelines.createNew((upstream) => upstream
            .pipe(transformation_pipeline_operators_1.Operators.Window.fixedSizeSliding(2))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.filter((it) => it.length === 2))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.map(([d1, d2]) => {
            const added = d2.value.filter((e2) => !d1.value.find((e1) => compareBy(e1, e2)));
            const removed = d1.value.filter((e1) => !d2.value.find((e2) => compareBy(e1, e2)));
            const diff = {
                added,
                removed,
            };
            const data = {
                value: diff,
                context: d2.context,
            };
            return data;
        }))
            .pipe(transformation_pipeline_operators_1.Operators.Transform.filter(({ value: { added, removed } }) => added.length + removed.length > 0))
            .pipe(rateLimit
            ? transformation_pipeline_operators_1.Operators.FlowControl.rateLimit(rateLimit.timeSpan)
            : transformation_pipeline_operators_1.Operators.Transform.identity()));
    }
    static threshold(trigger, rateLimit) {
        const triggerOperator = createTriggerOperator(trigger);
        return Pipelines.createNew((upstream) => upstream
            .pipe(...triggerOperator)
            .pipe(rateLimit
            ? transformation_pipeline_operators_1.Operators.FlowControl.rateLimit(rateLimit.timeSpan)
            : transformation_pipeline_operators_1.Operators.Transform.identity()));
    }
    static averageInFixedSizeWindowThreshold(window, trigger, rateLimit) {
        const triggerOperator = createTriggerOperator(trigger);
        return Pipelines.createNew((upstream) => upstream
            .pipe(transformation_pipeline_operators_1.Operators.Window.fixedSize(window.size))
            .pipe(transformation_pipeline_operators_1.Operators.Aggregate.avg())
            .pipe(...triggerOperator)
            .pipe(rateLimit
            ? transformation_pipeline_operators_1.Operators.FlowControl.rateLimit(rateLimit.timeSpan)
            : transformation_pipeline_operators_1.Operators.Transform.identity()));
    }
    static averageInFixedTimeWindowThreshold(window, trigger, rateLimit) {
        const triggerOperator = createTriggerOperator(trigger);
        return Pipelines.createNew((upstream) => upstream
            .pipe(...transformation_pipeline_operators_1.Operators.Window.fixedTime(window.timeSpan))
            .pipe(transformation_pipeline_operators_1.Operators.Aggregate.avg())
            .pipe(...triggerOperator)
            .pipe(rateLimit
            ? transformation_pipeline_operators_1.Operators.FlowControl.rateLimit(rateLimit.timeSpan)
            : transformation_pipeline_operators_1.Operators.Transform.identity()));
    }
    static averageInFixedSizeSlidingWindowThreshold(window, trigger, rateLimit) {
        const triggerOperator = createTriggerOperator(trigger);
        return Pipelines.createNew((upstream) => upstream
            .pipe(transformation_pipeline_operators_1.Operators.Window.fixedSizeSliding(window.size))
            .pipe(transformation_pipeline_operators_1.Operators.Aggregate.avg())
            .pipe(...triggerOperator)
            .pipe(rateLimit
            ? transformation_pipeline_operators_1.Operators.FlowControl.rateLimit(rateLimit.timeSpan)
            : transformation_pipeline_operators_1.Operators.Transform.identity()));
    }
    static notifyNewSubscribers() {
        return (source) => source.pipe(transformation_pipeline_operators_1.Operators.Transform.filter(({ value }) => value === 'added'));
    }
    static createNew(pipeline) {
        return pipeline;
    }
}
exports.Pipelines = Pipelines;
