"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Operators = exports.setPipeLogLevel = exports.PipeLogLevel = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
var PipeLogLevel;
(function (PipeLogLevel) {
    PipeLogLevel[PipeLogLevel["TRACE"] = 0] = "TRACE";
    PipeLogLevel[PipeLogLevel["DEBUG"] = 1] = "DEBUG";
    PipeLogLevel[PipeLogLevel["INFO"] = 2] = "INFO";
    PipeLogLevel[PipeLogLevel["ERROR"] = 3] = "ERROR";
})(PipeLogLevel = exports.PipeLogLevel || (exports.PipeLogLevel = {}));
let pipeLogLevel = PipeLogLevel.INFO;
function setPipeLogLevel(level) {
    pipeLogLevel = level;
}
exports.setPipeLogLevel = setPipeLogLevel;
class Operators {
}
exports.Operators = Operators;
Operators.Transform = class {
    static identity() {
        return (0, operators_1.map)((data) => data);
    }
    static filter(predicate) {
        return (0, rxjs_1.filter)(predicate);
    }
    static map(mapper) {
        return (0, operators_1.map)(mapper);
    }
};
Operators.Window = class {
    static fixedSize(size) {
        return (0, rxjs_1.bufferCount)(size);
    }
    static fixedSizeSliding(size) {
        return (0, rxjs_1.scan)((values, value) => values.slice(1 - size).concat(value), []);
    }
    static fixedTime(timeSpan) {
        return [
            (0, rxjs_1.windowTime)(timeSpan.toMillis()),
            (0, rxjs_1.concatMap)((value) => value.pipe((0, rxjs_1.toArray)())),
        ];
    }
};
Operators.Aggregate = class {
    static avg() {
        return (0, operators_1.map)((values) => {
            const acc = values.reduce((acc, next) => ({
                value: acc.value + next.value,
                context: next.context,
            }));
            return {
                ...acc,
                value: acc.value / values.length,
            };
        });
    }
    static max() {
        return (0, operators_1.map)((values) => values.reduce((acc, next) => (acc.value > next.value ? acc : next)));
    }
    static min() {
        return (0, operators_1.map)((values) => values.reduce((acc, next) => (acc.value < next.value ? acc : next)));
    }
};
Operators.Trigger = class {
    static risingEdge(threshold, limit) {
        return [
            Operators.Window.fixedSizeSliding(2),
            (0, rxjs_1.filter)((it) => it.length === 2 &&
                it[0].value <= threshold &&
                threshold < it[1].value &&
                (!limit || it[1].value < limit)),
            (0, operators_1.map)(([_, snd]) => snd),
        ];
    }
    static fallingEdge(threshold, limit) {
        return [
            Operators.Window.fixedSizeSliding(2),
            (0, rxjs_1.filter)((data) => data.length === 2 &&
                data[0].value >= threshold &&
                threshold > data[1].value &&
                (!limit || data[1].value > limit)),
            (0, operators_1.map)(([_, snd]) => snd),
        ];
    }
    static increase(threshold) {
        return [
            Operators.Window.fixedSizeSliding(2),
            (0, rxjs_1.filter)((data) => data.length === 2 && data[1].value - data[0].value >= threshold),
            (0, operators_1.map)(([fst, snd]) => ({
                ...snd,
                context: {
                    ...snd.context,
                    trace: [
                        ...snd.context.trace,
                        {
                            type: 'trigger',
                            input: [fst.value, snd.value],
                            output: snd.value - fst.value,
                        },
                    ],
                },
            })),
        ];
    }
    static decrease(threshold) {
        return [
            Operators.Window.fixedSizeSliding(2),
            (0, rxjs_1.filter)((data) => data.length === 2 && data[0].value - data[1].value >= threshold),
            (0, operators_1.map)(([_, snd]) => snd),
        ];
    }
};
Operators.FlowControl = class {
    static rateLimit(time) {
        return (0, rxjs_1.throttleTime)(time.toMillis());
    }
    static onErrorRetry() {
        return [
            (0, rxjs_1.catchError)((it) => {
                console.error(it);
                return (0, rxjs_1.timer)(1000).pipe((0, rxjs_1.mergeMap)(() => (0, rxjs_1.throwError)(it)));
            }),
            (0, rxjs_1.retry)(),
        ];
    }
};
Operators.Utility = class {
    static log(level, msg) {
        return (0, operators_1.tap)((value) => {
            if (level >= pipeLogLevel) {
                msg
                    ? console.log(`${msg}: ${JSON.stringify(value)}`)
                    : console.log(JSON.stringify(value));
            }
            return value;
        });
    }
};
