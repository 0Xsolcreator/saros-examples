"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DialectSdkSubscriberRepository = void 0;
const web3_js_1 = require("@solana/web3.js");
const lodash_1 = __importDefault(require("lodash"));
const sdk_1 = require("@dialectlabs/sdk");
class DialectSdkSubscriberRepository {
    constructor(sdk) {
        this.sdk = sdk;
        this.dapp = null;
    }
    subscribe(onSubscriberAdded, onSubscriberRemoved) {
        throw new Error('Method not implemented.');
    }
    async findAll() {
        const addressSubscribers = await this.findAddressSubscribers();
        const notificationSubscribers = await this.findNotificationTypeSubscribers();
        return lodash_1.default.values(lodash_1.default.merge(lodash_1.default.keyBy(addressSubscribers, (it) => it.resourceId.toBase58()), lodash_1.default.keyBy(notificationSubscribers, (it) => it.resourceId.toBase58())));
    }
    async findAddressSubscribers() {
        const dapp = await this.lookupDapp();
        const dappAddresses = await dapp.dappAddresses.findAll();
        return (0, lodash_1.default)(dappAddresses)
            .filter(({ enabled, address: { verified } }) => enabled && verified)
            .map((it) => ({
            resourceId: it.address.wallet.address,
            ...(it.address.type === sdk_1.AddressType.Email && {
                email: it.address.value,
            }),
            ...(it.address.type === sdk_1.AddressType.Telegram && {
                telegramChatId: it.channelId,
            }),
            ...(it.address.type === sdk_1.AddressType.PhoneNumber && {
                phoneNumber: it.address.value,
            }),
            ...(it.address.type === sdk_1.AddressType.Wallet && {
                wallet: new web3_js_1.PublicKey(it.address.value),
            }),
        }))
            .groupBy('resourceId')
            .mapValues((s, resourceId) => ({
            resourceId: new web3_js_1.PublicKey(resourceId),
            telegramChatId: s
                .map(({ telegramChatId }) => telegramChatId)
                .find((it) => it),
            phoneNumber: s.map(({ phoneNumber }) => phoneNumber).find((it) => it),
            email: s.map(({ email }) => email).find((it) => it),
            wallet: s.map(({ wallet }) => wallet).find((it) => it),
        }))
            .values()
            .value();
    }
    async findNotificationTypeSubscribers() {
        const dapp = await this.lookupDapp();
        const notificationTypes = await dapp.notificationTypes.findAll();
        if (notificationTypes.length === 0) {
            return [];
        }
        const dappNotificationSubscriptions = await dapp.notificationSubscriptions.findAll();
        return (0, lodash_1.default)(dappNotificationSubscriptions)
            .flatMap(({ subscriptions, notificationType }) => subscriptions.map((subscription) => {
            const notificationSubscription = {
                notificationType: {
                    id: notificationType.id,
                    humanReadableId: notificationType.humanReadableId,
                },
                config: subscription.config,
            };
            return {
                resourceId: subscription.wallet.address,
                subscription: notificationSubscription,
            };
        }))
            .groupBy('resourceId')
            .mapValues((s, resourceId) => {
            const subscriber = {
                resourceId: new web3_js_1.PublicKey(resourceId),
                notificationSubscriptions: s
                    .filter((it) => it.subscription.config.enabled)
                    .map((it) => it.subscription),
            };
            return subscriber;
        })
            .values()
            .value();
    }
    async lookupDapp() {
        if (!this.dapp) {
            const dapp = await this.sdk.dapps.find();
            if (!dapp) {
                throw new sdk_1.IllegalStateError(`Dapp ${this.sdk.wallet.address} not registered in dialect cloud ${this.sdk.config.dialectCloud}`);
            }
            this.dapp = dapp;
        }
        return this.dapp;
    }
}
exports.DialectSdkSubscriberRepository = DialectSdkSubscriberRepository;
