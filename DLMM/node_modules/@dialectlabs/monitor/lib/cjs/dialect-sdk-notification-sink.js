"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DialectSdkNotificationSink = void 0;
const sdk_1 = require("@dialectlabs/sdk");
const lodash_1 = require("lodash");
class DialectSdkNotificationSink {
    constructor(sdk, subscriberRepository) {
        this.sdk = sdk;
        this.subscriberRepository = subscriberRepository;
        this.dapp = null;
    }
    async push({ title, message, actions }, recipients, { dispatchType, notificationMetadata }) {
        try {
            const notificationTypeId = await this.tryResolveNotificationTypeId(notificationMetadata);
            const dapp = await this.lookupDapp();
            if (dispatchType === 'unicast') {
                const theOnlyRecipient = recipients[0];
                if (!theOnlyRecipient) {
                    throw new sdk_1.IllegalStateError(`No recipient specified for unicast notification`);
                }
                await dapp.messages.send({
                    title: title,
                    message: message,
                    recipient: theOnlyRecipient.toBase58(),
                    notificationTypeId,
                    actionsV2: actions,
                });
            }
            else if (dispatchType === 'multicast') {
                if (recipients.length === 0) {
                    return;
                }
                await dapp.messages.send({
                    title: title,
                    message: message,
                    recipients: recipients.map((it) => it.toBase58()),
                    notificationTypeId,
                    actionsV2: actions,
                });
            }
            else if (dispatchType === 'broadcast') {
                await dapp.messages.send({
                    title: title,
                    message: message,
                    notificationTypeId,
                    actionsV2: actions,
                });
            }
            else {
                console.error(`Dialect SDK notification sink does not support this dispatch type: ${dispatchType}.`);
            }
        }
        catch (e) {
            console.error(`Failed to send dialect sdk notification, reason: ${JSON.stringify(e)}`);
        }
        return;
    }
    tryResolveNotificationTypeId(notificationMetadata) {
        const notificationTypeId = notificationMetadata === null || notificationMetadata === void 0 ? void 0 : notificationMetadata.type.id;
        if (notificationTypeId) {
            return this.resolveNotificationTypeId(notificationTypeId);
        }
    }
    async resolveNotificationTypeId(notificationTypeId) {
        const subscribers = await this.subscriberRepository.findAll();
        const availableNotificationTypes = (0, lodash_1.uniqBy)(subscribers
            .flatMap((it) => { var _a; return (_a = it.notificationSubscriptions) !== null && _a !== void 0 ? _a : []; })
            .map((it) => it.notificationType), (it) => it.id);
        const notificationType = availableNotificationTypes.find((it) => it.humanReadableId.toLowerCase() === notificationTypeId.toLowerCase() ||
            it.id === notificationTypeId);
        if (availableNotificationTypes.length > 0 && !notificationType) {
            throw new sdk_1.IllegalStateError(`Unknown notification type ${notificationTypeId}, must be one of [${availableNotificationTypes.map((it) => it.humanReadableId)}] or one of [${availableNotificationTypes.map((it) => it.id)}]`);
        }
        return notificationType === null || notificationType === void 0 ? void 0 : notificationType.id;
    }
    async lookupDapp() {
        if (!this.dapp) {
            const dapp = await this.sdk.dapps.find();
            if (!dapp) {
                throw new sdk_1.IllegalStateError(`Dapp ${this.sdk.wallet.address} not registered in dialect cloud ${this.sdk.config.dialectCloud}`);
            }
            this.dapp = dapp;
        }
        return this.dapp;
    }
}
exports.DialectSdkNotificationSink = DialectSdkNotificationSink;
